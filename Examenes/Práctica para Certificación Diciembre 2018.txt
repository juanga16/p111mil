1. Dado el siguiente de Diagrama de Entidad-Relación y la consulta
SQL. Modifique la consulta SQL ya que contiene errores y describa el
resultado de la consulta.

SELECT id_proveedor, id_articulo
FROM Proveedor p JOIN Envio e ON p.nombre = e.id_proveedor
	
Error 1: JOIN no corresponde comparar nombre con id_proveedor
Error 2: Debemos anteponer el alias en el select cuando el nombre del campo se repite en varias tablas

SELECT p.id_proveedor, e.id_articulo
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor

Una version mejorada:

SELECT p.id_proveedor, p.nombre, e.id_articulo, a.descripcion
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor
JOIN Articulo a ON a.id_articulo = e.id_articulo

Esta consulta lista los articulos que se encargaron a los distintos proveedores.

2. Dado el siguiente de Diagrama de Entidad-Relación y la consulta
SQL. Modifique la consulta SQL ya que contiene errores y describa el
resultado de la consulta.

Consulta corregida:
SELECT SUM (e.cantidad), e.id_proveedor, e.id_articulo
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor
AND e.id_articulo IN (SELECT a.descripcion FROM Articulo a)

Error #1: El AND se reemplaza por el WHERE
Error #2: En la sub consulta del IN devolver id_articulo en vez de descripcion
Error #3: Reemplazamos el SUM por COUNT para calcular la cantidad de veces que un proveedor envio un determinado articulo

Consulta corregida:
SELECT COUNT (e.cantidad), e.id_proveedor, e.id_articulo
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor
WHERE e.id_articulo IN (SELECT a.id_articulo FROM Articulo a)

Esta consulta calcula la cantidad de veces que un proveedor envio un determinado articulo

3. Dada la siguiente consulta SQL y las siguientes tuplas de ejemplo,
determinar el resultado de la consulta:

SELECT SUM (e.cantidad), e.id_proveedor, e.id_articulo
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor
AND e.id_articulo IN (SELECT a.id_articulo FROM Articulo a)
HAVING e.cantidad > 100
GROUP BY e.id_proveedor
ORDER BY e.ciudad DESC

Tuplas de ejemplo:

ARTICULO:
1,”articulo A”, 30, “Tandil”
2,”articulo B”, 50, “Balcarce”
3,”articulo C”, 10, “Olavarría”
4,”articulo D”, 60, “Pinamar”

PROVEEDOR:
1, “producto X”, “limpieza”, “Tandil”
2, “producto Y”, “higiene”, “Azul”
3, “producto Z”, “farmacia”, “Bolivar”
4, “producto W”, “limpieza”, “Mar del Plata”

ENVIO:
1,1,120
1,2,160
3,1,90
4,3,100

Consulta corregida:
SELECT COUNT (e.cantidad), e.id_proveedor, e.id_articulo
FROM Proveedor p JOIN Envio e ON p.id_proveedor = e.id_proveedor
WHERE e.id_articulo IN (SELECT a.id_articulo FROM Articulo a)
GROUP BY e.id_proveedor, e.id_articulo, p.ciudad
HAVING COUNT (e.cantidad) > 100
ORDER BY p.ciudad DESC

Error #1: El SUM se reemplaza por el COUNT
Error #2: El AND se reemplaza por el WHERE
Error #3: El HAVING siempre va despues del GROUP BY
Error #4: En el ORDER BY no se puede usar e porque ENVIO no tiene Ciudad

Retorna la cantidad de veces que un proveedor envio un determinado articulo,
siempre y cuando la cantidad es mayor a cien y ordena por la ciudad del proveedor descendentemente.

Los datos de la tabla ENVIO son invalidos ya que no existen ARTICULOS con esos valores.
Ademas los valores de CANTIDAD estan repetidos.

Corregimos los valores de ENVIO:
1,1,1
101,2,1
120,1,3
198,3,2
222,1,4
1500,1,1
900,2,3

4. El equipo administrativo que trabaja con el director de un colegio se
encuentra en este momento contabilizando los estudiantes que al
menos aprobaron 1 curso de los que ofrece el Programa 111Mil en el
Colegio Secundario Nº1. En su base de datos existe información de
los alumnos, de los cursos y de las inscripciones a dichos cursos. A
partir del DER del ejercicio anterior, el equipo necesita listar el
nombre y apellido de cada alumno, con su DNI, edad y el nombre del
o los curso/s con nota 7 ó superior. El listado debe estar ordenado
alfabéticamente por el apellido del alumno. El equipo necesita que
escribas la consulta SQL correspondiente.

SELECT a.Nombre, a.Apellido, a.DNI, a.Edad, c.Nombre
FROM Alumno a
JOIN Inscripcion i ON i.Alumno_DNI = a.DNI
JOIN Curso c ON c.idCurso = i.Curso_idCurso
WHERE i.Nota >= 7
ORDER BY a.Apellido

5. Dado el siguiente diagrama de entidad-relación, escriba una consulta
SQL que liste los números de orden (id) de todas las órdenes
pertenecientes a clientes con apellido Rodriguez.

SELECT o.idOrden
FROM Orden o
JOIN Cliente c ON o.Cliente_dni = c.dni
WHERE c.apellido = 'Rodriguez'

6. Dada la siguiente porción de clase en Java y la sentencia de DDL de
creación de la tabla escriba la línea del archivo de mapeo de
Hibernate HBM en formato XML correspondiente al mapeo del
atributo “monto”.

Infraccion.java
public class Infraccion {
private Integer id;
private InfraccionNomenclada infraccionNomenclada;
private Integer cantidadPuntosDescontados;
private BigDecimal monto;
private String observacion;
Script SQL de creación de la tabla

CREATE TABLE `Infraccion` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`cantidadPuntosDescontados` tinyint(3) unsigned DEFAULT NULL,
`monto` decimal(8,2) unsigned NOT NULL,
`observacion` varchar(255) DEFAULT NULL,
`numeroActaConstatacion` int(10) unsigned NOT NULL,
`codigoInfraccionNomenclada` int(10) unsigned NOT NULL
PRIMARY KEY (`id`),
KEY `fk_Infraccion_ActaConstatacion1_idx` (`numeroActaConstatacion`),
KEY `fk_Infraccion_InfraccionNomenclada1_idx` (`codigoInfraccionNomenclada`),
CONSTRAINT `fk_Infraccion_ActaConstatacion1`
FOREIGN KEY (`numeroActaConstatacion`) REFERENCES `ActaConstatacion` (`numero`)
ON DELETE NO ACTION ON UPDATE NO ACTION,
CONSTRAINT `fk_Infraccion_InfraccionNomenclada1`
FOREIGN KEY (`codigoInfraccionNomenclada`) REFERENCES `InfraccionNomenclada`
(`codigo`)
ON DELETE NO ACTION ON UPDATE NO ACTION
)

Comentarios:
Define una relacion entre Infraccion y ActaConstatacion a traves de las columnas
numero en ActaConstatacion y numeroActaConstatacion en Infraccion-

<property name="monto" type="java.math.BigDecimal">
	<column name="monto" />
</property>

BigDecimal pertenece al paquete java.math
Date pertenece al paquete java utils

7. Dada la siguiente porción de clase en Java y la sentencia de DDL de
creación de la tabla escriba la línea del archivo de mapeo de
Hibernate HBM en formato XML correspondiente al mapeo del
atributo “infraccionNomenclada”.
Infraccion.java

public class Infraccion {
private Integer id;
private InfraccionNomenclada infraccionNomenclada;
private Integer cantidadPuntosDescontados;
private BigDecimal monto;
private String observacion;

Script SQL de creación de la tabla
CREATE TABLE `Infraccion` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`cantidadPuntosDescontados` tinyint(3) unsigned DEFAULT NULL,
`monto` decimal(8,2) unsigned NOT NULL,
`observacion` varchar(255) DEFAULT NULL,
`numeroActaConstatacion` int(10) unsigned NOT NULL,
`codigoInfraccionNomenclada` int(10) unsigned NOT NULL
PRIMARY KEY (`id`),
KEY `fk_Infraccion_ActaConstatacion1_idx` (`numeroActaConstatacion`),
KEY `fk_Infraccion_InfraccionNomenclada1_idx` (`codigoInfraccionNomenclada`),
CONSTRAINT `fk_Infraccion_ActaConstatacion1`
FOREIGN KEY (`numeroActaConstatacion`) REFERENCES `ActaConstatacion` (`numero`)
ON DELETE NO ACTION ON UPDATE NO ACTION,
CONSTRAINT `fk_Infraccion_InfraccionNomenclada1`
FOREIGN KEY (`codigoInfraccionNomenclada`) REFERENCES `InfraccionNomenclada`
(`codigo`)
ON DELETE NO ACTION ON UPDATE NO ACTION
)

Comentarios:
Infraccion tiene un atributo del tipo InfraccionNomenclada

<many-to-one name="infraccionNomenclada" class="InfraccionNomenclada" column="codigoInfraccionNomenclada" cascade="none" not-null="true" insert="true" update="false" lazy="false" />